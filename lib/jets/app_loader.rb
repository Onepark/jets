# frozen_string_literal: true

require "pathname"
require "jets/version"

module Jets
  module AppLoader # :nodoc:
    extend self

    RUBY = Gem.ruby
    EXECUTABLES = ["bin/jets", "script/jets"]
    BUNDLER_WARNING = <<EOS
Beginning in Jets 5, Jets ships with a `jets` binstub at ./bin/jets that
should be used instead of the Bundler-generated `jets` binstub.

If you are seeing this message, your binstub at ./bin/jets was generated by
Bundler instead of Jets.

You might need to regenerate your `jets` binstub locally and add it to source
control:

 jets app:update:bin           # Bear in mind this generates other binstubs
                               # too that you may or may not want (like yarn)

If you already have Jets binstubs in source control, you might be
inadvertently overwriting them during deployment by using bundle install
with the --binstubs option.

If your application was created prior to Jets 4, here's how to upgrade:

  bundle config --delete bin    # Turn off Bundler's stub generator
  jets app:update:bin          # Use the new Jets executables
  git add bin                   # Add bin/ to source control

You may need to remove bin/ from your .gitignore as well.

When you install a gem whose executable you want to use in your app,
generate it and add it to source control:

  bundle binstubs some-gem-name
  git add bin/new-executable

EOS

    def exec_app
      original_cwd = Dir.pwd

      loop do
        if exe = find_executable
          contents = File.read(exe)

          if /(APP|ENGINE)_PATH/.match?(contents)
            exec RUBY, exe, *ARGV
            break # non reachable, hack to be able to stub exec in the test suite
          elsif exe.end_with?("bin/jets") && contents.include?("This file was generated by Bundler")
            $stderr.puts(BUNDLER_WARNING)
            Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
            # Do not run Jets.boot here else -e option is not respected. IE: jets console -e production
            require "jets/commands"
            break
          end
        end

        # If we exhaust the search there is no executable, this could be a
        # call to generate a new application, so restore the original cwd.
        Dir.chdir(original_cwd) && return if Pathname.new(Dir.pwd).root?

        # Otherwise keep moving upwards in search of an executable.
        Dir.chdir("..")
      end
    end

    def find_executable
      EXECUTABLES.find { |exe| File.file?(exe) }
    end
  end
end
